require('dotenv').config();
const { Client, LocalAuth } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const fs = require('fs').promises;
const axios = require('axios'); // npm install axios

// === IMPORTAR A IA ATACADO ===
const WhatsAppAIAtacado = require('./whatsapp_ai_atacado');

// === IMPORTAR O BOT DE DIVIS√ÉO ===
const WhatsAppBotDivisao = require('./whatsapp_bot_divisao');

// === CONFIGURA√á√ÉO GOOGLE SHEETS - BOT ATACADO (CONFIGURADA) ===
const GOOGLE_SHEETS_CONFIG_ATACADO = {
    scriptUrl: process.env.GOOGLE_SHEETS_SCRIPT_URL_ATACADO || 'https://script.google.com/macros/s/AKfycbzdvM-IrH4a6gS53WZ0J-AGXY0duHfgv15DyxdqUm1BLEm3Z15T67qgstu6yPTedgOSCA/exec',
    planilhaUrl: 'https://docs.google.com/spreadsheets/d/1ivc8gHD5WBWsvcwmK2dLBWpEHCI9J0C17Kog2NesuuE/edit',
    planilhaId: '1ivc8gHD5WBWsvcwmK2dLBWpEHCI9J0C17Kog2NesuuE',
    timeout: 30000,
    retryAttempts: 3,
    retryDelay: 2000
};

// === CONFIGURA√á√ÉO GOOGLE SHEETS - SALDO (NOVA) ===
const GOOGLE_SHEETS_CONFIG_SALDO = {
    scriptUrl: process.env.GOOGLE_SHEETS_SCRIPT_URL_SALDO || 'https://script.google.com/macros/s/AKfycby9UrgOSXkCnAKt4Csd3IPG6pr8i9jmgycrBy_cvsOT7x8eY0-EmJOmooSvw3eRuvF2tQ/exec',
    planilhaUrl: 'https://docs.google.com/spreadsheets/d/1fIE-bODZOF0oyUY-y5oUGL2g_LYzwoKdjdwc3bGo8hQ/edit',
    planilhaId: '1fIE-bODZOF0oyUY-y5oUGL2g_LYzwoKdjdwc3bGo8hQ',
    timeout: 30000,
    retryAttempts: 3,
    retryDelay: 2000
};

// === CONFIGURA√á√ÉO GOOGLE SHEETS - BOT RETALHO (mantida para compatibilidade) ===
const GOOGLE_SHEETS_CONFIG = {
    scriptUrl: process.env.GOOGLE_SHEETS_SCRIPT_URL || 'https://script.google.com/macros/s/AKfycbz.../exec',
    timeout: 30000,
    retryAttempts: 3,
    retryDelay: 2000,
    planilhaId: process.env.GOOGLE_SHEETS_ID || '1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms',
    nomePlanilha: 'Dados Retalho',
    colunas: {
        timestamp: 'A',
        referencia: 'B',
        valor: 'C',
        numero: 'D',
        grupo: 'E',
        autor: 'F',
        status: 'G'
    }
};

console.log(`üìä Google Sheets configurado: ${GOOGLE_SHEETS_CONFIG_ATACADO.scriptUrl}`);

// Criar inst√¢ncia do cliente
const client = new Client({
    authStrategy: new LocalAuth({
        clientId: "bot_atacado" // Diferente do bot retalho
    }),
    puppeteer: {
        headless: true,
        args: [
            '--no-sandbox', 
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-extensions',
            '--no-first-run',
            '--no-default-browser-check',
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-renderer-backgrounding',
            '--disable-features=TranslateUI',
            '--disable-ipc-flooding-protection'
        ],
        timeout: 60000
    }
});

// === INICIALIZAR A IA ===
require('dotenv').config();
const ia = new WhatsAppAIAtacado(process.env.OPENAI_API_KEY);

// === INICIALIZAR O BOT DE DIVIS√ÉO ===
const botDivisao = new WhatsAppBotDivisao();

// Configura√ß√£o para encaminhamento
const ENCAMINHAMENTO_CONFIG = {
    grupoOrigem: '120363402160265624@g.us', // Grupo de atacado
    numeroDestino: '258861645968@c.us',
    intervaloSegundos: 2
};

// Fila de mensagens para encaminhar
let filaMensagens = [];
let processandoFila = false;

// === VARI√ÅVEIS PARA DADOS ===
let dadosParaTasker = [];

// Base de dados de compradores
let historicoCompradores = {};
const ARQUIVO_HISTORICO = 'historico_compradores_atacado.json';

// Cache de administradores dos grupos
let adminCache = {};

// Cache para evitar logs repetidos de grupos
let gruposLogados = new Set();

// Configura√ß√£o de administradores GLOBAIS
const ADMINISTRADORES_GLOBAIS = [
    '258861645968@c.us',
    '258871112049@c.us',
    '258852118624@c.us',
    '258840326152@c.us'  // Adicionado para comandos administrativos
];

// === MAPEAMENTO DE N√öMEROS PARA GRUPOS ===
const MAPEAMENTO_NUMEROS_GRUPOS = {
    '258840326152': '120363419652375064@g.us',  // Net Fornecedor V
    '258852118624': '120363419652375064@g.us'   // Net Fornecedor V
};

// === CONFIGURA√á√ÉO DE MODERA√á√ÉO ===
const MODERACAO_CONFIG = {
    ativado: {
        '120363402160265624@g.us': true
    },
    detectarLinks: true,
    apagarMensagem: true,
    removerUsuario: false,
    excecoes: [
        '258861645968@c.us',
        '258871112049@c.us',
        '258852118624@c.us',
        '258840326152@c.us'
    ]
};

// === CONFIGURA√á√ÉO DOS GRUPOS PARA O BOT DE DIVIS√ÉO ===
// Esta configura√ß√£o deve estar sincronizada com CONFIGURACAO_GRUPOS
const CONFIGURACAO_GRUPOS_DIVISAO = {
    '120363419652375064@g.us': {
        nome: 'Net Fornecedor V',
        precos: {
            10240: 125,    // 10GB = 125MT
            20480: 250,    // 20GB = 250MT
            30720: 375,    // 30GB = 375MT
            40960: 500,    // 40GB = 500MT
            51200: 625,    // 50GB = 625MT
            61440: 750,    // 60GB = 750MT
            71680: 875,    // 70GB = 875MT
            81920: 1000,   // 80GB = 1000MT
            92160: 1125,   // 90GB = 1125MT
            102400: 1250   // 100GB = 1250MT
        },
        // === TABELA DE SALDO NET FORNECEDOR V ===
        precosSaldo: {
            50: 45,      // 50MT saldo = 45MT pagamento
            100: 85,     // 100MT saldo = 85MT pagamento
            200: 170,    // 200MT saldo = 170MT pagamento
            300: 255,    // 300MT saldo = 255MT pagamento
            400: 340,    // 400MT saldo = 340MT pagamento
            500: 410,    // 500MT saldo = 410MT pagamento
            1000: 815,   // 1000MT saldo = 815MT pagamento
            2000: 1630,  // 2000MT saldo = 1630MT pagamento
            3000: 2445,  // 3000MT saldo = 2445MT pagamento
            4000: 3260,  // 4000MT saldo = 3260MT pagamento
            5000: 4075,  // 5000MT saldo = 4075MT pagamento
            6000: 4890,  // 6000MT saldo = 4890MT pagamento
            7000: 5705,  // 7000MT saldo = 5705MT pagamento
            8000: 6520,  // 8000MT saldo = 6520MT pagamento
            9000: 7335,  // 9000MT saldo = 7335MT pagamento
            10000: 8150  // 10000MT saldo = 8150MT pagamento
        }
    },
    '120363402160265624@g.us': {
        nome: 'Treinamento IA',
        precos: {
            10240: 130,    // 10GB = 130MT
            20480: 260,    // 20GB = 260MT
            30720: 390,    // 30GB = 390MT
            40960: 520,    // 40GB = 520MT
            51200: 630,    // 50GB = 630MT
            61440: 750,    // 60GB = 750MT
            71680: 875,    // 70GB = 875MT
            81920: 1000    // 80GB = 1000MT
        },
        // === TABELA DE SALDO TREINAMENTO ===
        precosSaldo: {
            50: 45,      // 50MT saldo = 45MT pagamento
            100: 90,     // 100MT saldo = 90MT pagamento
            200: 180,    // 200MT saldo = 180MT pagamento
            300: 270,    // 300MT saldo = 270MT pagamento
            500: 450,    // 500MT saldo = 450MT pagamento
            1000: 900    // 1000MT saldo = 900MT pagamento
        }
    }
    // Only Saldo foi removido pois n√£o precisa de divis√£o autom√°tica
};

// Atualizar a configura√ß√£o do bot de divis√£o
botDivisao.CONFIGURACAO_GRUPOS = CONFIGURACAO_GRUPOS_DIVISAO;

// Configura√ß√£o para cada grupo (ATACADO)
const CONFIGURACAO_GRUPOS = {
    '120363419652375064@g.us': {
        nome: 'Net Fornecedor V',
        // CORRE√á√ÉO: Adicionar pre√ßos estruturados para c√°lculo correto de megas
        precos: {
            10240: 125,    // 10GB = 125MT
            20480: 250,    // 20GB = 250MT
            30720: 375,    // 30GB = 375MT
            40960: 500,    // 40GB = 500MT
            51200: 625,    // 50GB = 625MT
            61440: 750,    // 60GB = 750MT
            71680: 875,    // 70GB = 875MT
            81920: 1000,   // 80GB = 1000MT
            92160: 1125,   // 90GB = 1125MT
            102400: 1250   // 100GB = 1250MT
        },
        // === TABELA DE SALDO NET FORNECEDOR V ===
        precosSaldo: {
            50: 45,      // 50MT saldo = 45MT pagamento
            100: 85,     // 100MT saldo = 85MT pagamento
            200: 170,    // 200MT saldo = 170MT pagamento
            300: 255,    // 300MT saldo = 255MT pagamento
            400: 340,    // 400MT saldo = 340MT pagamento
            500: 410,    // 500MT saldo = 410MT pagamento
            1000: 815,   // 1000MT saldo = 815MT pagamento
            2000: 1630,  // 2000MT saldo = 1630MT pagamento
            3000: 2445,  // 3000MT saldo = 2445MT pagamento
            4000: 3260,  // 4000MT saldo = 3260MT pagamento
            5000: 4075,  // 5000MT saldo = 4075MT pagamento
            6000: 4890,  // 6000MT saldo = 4890MT pagamento
            7000: 5705,  // 7000MT saldo = 5705MT pagamento
            8000: 6520,  // 8000MT saldo = 6520MT pagamento
            9000: 7335,  // 9000MT saldo = 7335MT pagamento
            10000: 8150  // 10000MT saldo = 8150MT pagamento
        },
        tabela: `GB'S COMPLETOS
üì± 10GB‚ûú125MT 
üì± 20GB ‚ûú 250MT  
üì± 30GB ‚ûú 375MT  
üì± 40GB ‚ûú 500MT  
üì± 50GB ‚ûú 625MT  
üì± 60GB ‚ûú 750MT  
üì± 70GB ‚ûú 875MT  
üì± 80GB ‚ûú 1000MT  
üì± 90GB ‚ûú 1125MT  
üì± 100GB‚ûú1250MT

üìû 1 Comprovante = 1 N√∫mero = Valor Completo`,

        pagamento: `FORMAS DE PAGAMENTO
 
M-PESA‚ù§: 840326152 
E-MOLAüß°: 870059057 
NOME: Vasco Jos√© Mahumane 

üìù Ap√≥s a transfer√™ncia, mande:
1Ô∏è‚É£ Comprovativo 
2Ô∏è‚É£ UM n√∫mero que vai receber`
    },
    '120363419741642342@g.us': {
        nome: 'Only Saldo',
        tabela: `SALDO PROMO 1Küü∞815üìû
    
 üìû 50      üí´ 45     MT
 üìû 100    üí´ 85     MT
üìû 200     üí´ 170   MT
üìû 300     üí´ 255   MT
üìû 400     üí´ 340   MT
üìû 500     üí´ 410   MT 
üìû 1000   üí´ 815   MT
üìû 2000   üí´ 1630 MT
üìû 3000   üí´ 2445 MT
üìû 4000   üí´ 3260 MT
üìû 5000   üí´ 4075 MT
üìû 6000   üí´ 4890 MT
üìû 7000   üí´ 5705 MT
üìû 8000   üí´ 6520 MT
üìû 9000   üí´ 7335 MT
üìû 10000 üí´ 8150 MT

üì© Ap√≥s o envio do valor, mande o compravativo no grupo e o respectivo n√∫mero¬†benefici√°rio.`,

        pagamento: `FORMAS DE PAGAMENTO
 
M-PESA‚ù§: 840326152 
E-MOLAüß°: 870059057 
NOME: Vasco Jos√© Mahumane 

üìù Ap√≥s a transfer√™ncia, mande:
1Ô∏è‚É£ Comprovativo 
2Ô∏è‚É£ UM n√∫mero que vai receber`
    },
    '120363402160265624@g.us': {
        nome: 'Treinamento IA',
        precos: {
            10240: 130,    // 10GB = 130MT
            20480: 260,    // 20GB = 260MT
            30720: 390,    // 30GB = 390MT
            40960: 520,    // 40GB = 520MT
            51200: 630,    // 50GB = 630MT
            61440: 750,    // 60GB = 750MT
            71680: 875,    // 70GB = 875MT
            81920: 1000    // 80GB = 1000MT
        },
        // === TABELA DE SALDO TREINAMENTO ===
        precosSaldo: {
            50: 45,      // 50MT saldo = 45MT pagamento
            100: 90,     // 100MT saldo = 90MT pagamento
            200: 180,    // 200MT saldo = 180MT pagamento
            300: 270,    // 300MT saldo = 270MT pagamento
            500: 450,    // 500MT saldo = 450MT pagamento
            1000: 900    // 1000MT saldo = 900MT pagamento
        },
        tabela: `üö®PROMO√á√ÉO DE GIGABYTESüö®
MAIS DE 40 GIGABYTES 12.5
Oferecemos-lhe servi√ßos extremamente r√°pido e seguro.ü•≥
üõúüì∂ TABELA NORMALüåê
‚ô® GB'süõú COMPLETOSüî•
üåê 10GB  üî∞   130MTüí≥
üåê 20GB  üî∞   260MTüí≥
üåê 30GB  üî∞   390MTüí≥
üåê 40GB  üî∞   520MTüí≥

PACOTE VIP 12.5 24H
üåê 50GB  üî∞   630MTüí≥
üåê 60GB  üî∞   750MTüí≥
üåê 70GB  üî∞   875MTüí≥
üåê 80GB  üî∞ 1000MTüí≥

SINTAM-SE AVONTADE, EXPLOREM-NOS ENQUANTO PUDEREM!`,

        pagamento: `FORMAS DE PAGAMENTO
 
M-PESA‚ù§: 840326152 
E-MOLAüß°: 870059057 
NOME: Vasco Jos√© Mahumane 

üìù Ap√≥s a transfer√™ncia, mande:
1Ô∏è‚É£ Comprovativo 
2Ô∏è‚É£ UM n√∫mero que vai receber`
    }
};

// === FUN√á√ÉO GOOGLE SHEETS ===

// Fun√ß√£o para retry autom√°tico
async function tentarComRetry(funcao, maxTentativas = 3, delay = 2000) {
    for (let tentativa = 1; tentativa <= maxTentativas; tentativa++) {
        try {
            return await funcao();
        } catch (error) {
            console.log(`‚ö†Ô∏è Tentativa ${tentativa}/${maxTentativas} falhou: ${error.message}`);
            
            if (tentativa === maxTentativas) {
                throw error; // √öltima tentativa, propagar erro
            }
            
            // Aguardar antes da pr√≥xima tentativa
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

// === FUN√á√ÉO GOOGLE SHEETS PARA SALDO ===
async function enviarSaldoParaGoogleSheets(dadosCompletos, grupoId, timestamp) {
    const dados = {
        grupo_id: grupoId,
        timestamp: timestamp,
        dados: dadosCompletos,
        tipo: 'saldo'
    };

    try {
        console.log(`üìä SALDO: Enviando para Google Sheets...`);

        const resultado = await tentarComRetry(async () => {
            const response = await axios.post(GOOGLE_SHEETS_CONFIG_SALDO.scriptUrl, dados, {
                timeout: GOOGLE_SHEETS_CONFIG_SALDO.timeout,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            return response.data;
        }, GOOGLE_SHEETS_CONFIG_SALDO.retryAttempts, GOOGLE_SHEETS_CONFIG_SALDO.retryDelay);

        console.log(`‚úÖ SALDO: Dados enviados para Google Sheets:`, resultado);
        return { sucesso: true, dados: resultado };

    } catch (error) {
        console.error(`‚ùå SALDO: Erro ao enviar para Google Sheets:`, error.message);
        return { sucesso: false, erro: error.message };
    }
}

// === FUN√á√ÉO GOOGLE SHEETS SIMPLIFICADA ===
async function enviarParaGoogleSheets(dadosCompletos, grupoId, timestamp) {
    const dados = {
        grupo_id: grupoId,
        timestamp: timestamp,
        dados: dadosCompletos  // REF|MEGAS|NUMERO|TIMESTAMP como string √∫nica
    };
    
    try {
        console.log(`üìä Enviando para Google Sheets SIMPLIFICADO: ${dadosCompletos}`);
        console.log(`üìç Grupo: ${grupoId}`);
        console.log(`‚è∞ Timestamp: ${timestamp}`);
        
        const response = await axios.post(GOOGLE_SHEETS_CONFIG_ATACADO.scriptUrl, dados, {
            timeout: GOOGLE_SHEETS_CONFIG_ATACADO.timeout,
            headers: {
                'Content-Type': 'application/json',
                'X-Bot-Source': 'WhatsApp-Bot-Atacado-Simplificado'
            },
            validateStatus: function (status) {
                return status < 500;
            }
        });
        
        // Log detalhado da resposta para debug
        console.log(`üîç DEBUG Google Sheets Response:`, {
            status: response.status,
            statusText: response.statusText,
            data: response.data,
            dataType: typeof response.data,
            hasSuccess: response.data?.success,
            hasError: response.data?.error
        });
        
        if (response.data && response.data.success) {
            console.log(`‚úÖ Google Sheets: Dados enviados! Row: ${response.data.row}`);
            console.log(`üìã Dados inseridos: ${response.data.dados}`);
            return { sucesso: true, row: response.data.row };
        } else if (response.data && response.data.duplicado) {
            // Caso especial: Pagamento duplicado
            console.log(`‚ö†Ô∏è Google Sheets: Pagamento duplicado - ${response.data.referencia}`);
            return { 
                sucesso: false, 
                duplicado: true, 
                referencia: response.data.referencia,
                erro: `Pagamento duplicado: ${response.data.referencia}` 
            };
        } else {
            const errorMsg = response.data?.error || `Resposta inv√°lida: ${JSON.stringify(response.data)}`;
            throw new Error(errorMsg);
        }
        
    } catch (error) {
        console.error(`‚ùå Erro Google Sheets: ${error.message}`);
        return { sucesso: false, erro: error.message };
    }
}

// === FUN√á√ÉO PARA NORMALIZAR VALORES (remove v√≠rgulas e converte) ===
function normalizarValor(valor) {
    if (typeof valor === 'number') {
        return valor;
    }
    
    if (typeof valor === 'string') {
        let valorLimpo = valor.trim();
        
        // Casos especiais: valores com m√∫ltiplos zeros ap√≥s v√≠rgula (ex: "1,0000" = 1000MT)
        // Padr√£o: n√∫mero seguido de v√≠rgula e s√≥ zeros
        const regexZerosAposVirgula = /^(\d+),0+$/;
        const matchZeros = valorLimpo.match(regexZerosAposVirgula);
        if (matchZeros) {
            // "1,0000" significa 1000 meticais (v√≠rgula + zeros = multiplicador de milhares)
            const baseNumero = parseInt(matchZeros[1]);
            const numeroZeros = valorLimpo.split(',')[1].length;
            // Para "1,0000": base=1, zeros=4, ent√£o 1 * 1000 = 1000
            const multiplicador = numeroZeros >= 3 ? 1000 : Math.pow(10, numeroZeros);
            return baseNumero * multiplicador;
        }
        
        // Detectar se v√≠rgula √© separador de milhares ou decimal
        const temVirgulaSeguida3Digitos = /,\d{3}($|\D)/.test(valorLimpo);
        
        if (temVirgulaSeguida3Digitos) {
            // V√≠rgula como separador de milhares: "1,000" ou "10,500.50"
            valorLimpo = valorLimpo.replace(/,(?=\d{3}($|\D))/g, '');
        } else {
            // V√≠rgula como separador decimal: "1,50" ‚Üí "1.50"
            valorLimpo = valorLimpo.replace(',', '.');
        }
        
        const valorNumerico = parseFloat(valorLimpo);
        
        if (isNaN(valorNumerico)) {
            console.warn(`‚ö†Ô∏è Valor n√£o p√¥de ser normalizado: "${valor}"`);
            return valor;
        }
        
        // Retorna inteiro se n√£o tem decimais significativos
        return (Math.abs(valorNumerico % 1) < 0.0001) ? Math.round(valorNumerico) : valorNumerico;
    }
    
    return valor;
}

// === FUN√á√ÉO PARA VERIFICAR PAGAMENTO (reutiliza mesma l√≥gica da divis√£o) ===
async function verificarPagamentoIndividual(referencia, valorEsperado) {
    try {
        // Normalizar valor antes da verifica√ß√£o
        const valorNormalizado = normalizarValor(valorEsperado);
        
        console.log(`üîç INDIVIDUAL: Verificando pagamento ${referencia} - ${valorNormalizado}MT (original: ${valorEsperado})`);
        
        // Usar mesma URL e estrutura do bot de divis√£o
        const response = await axios.post(botDivisao.SCRIPTS_CONFIG.PAGAMENTOS, {
            action: "buscar_por_referencia",
            referencia: referencia,
            valor: valorNormalizado
        }, {
            timeout: 30000,
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        if (response.data && response.data.encontrado) {
            console.log(`‚úÖ INDIVIDUAL: Pagamento encontrado!`);
            return true;
        }
        
        console.log(`‚ùå INDIVIDUAL: Pagamento n√£o encontrado`);
        return false;
        
    } catch (error) {
        console.error(`‚ùå INDIVIDUAL: Erro ao verificar pagamento:`, error.message);
        return false;
    }
}

// === FUN√á√ÉO PARA CALCULAR VALOR ESPERADO BASEADO NOS MEGAS ===
function calcularValorEsperadoDosMegas(megas, grupoId) {
    try {
        const configGrupo = getConfiguracaoGrupo(grupoId);
        if (!configGrupo || !configGrupo.precos) {
            console.log(`‚ö†Ô∏è INDIVIDUAL: Grupo ${grupoId} n√£o tem tabela de pre√ßos configurada`);
            return null;
        }
        
        // Converter megas para n√∫mero se for string
        const megasNum = typeof megas === 'string' ? 
            parseInt(megas.replace(/[^\d]/g, '')) : parseInt(megas);
        
        // Buscar o pre√ßo correspondente na tabela
        const valorEncontrado = configGrupo.precos[megasNum];
        
        if (valorEncontrado) {
            console.log(`üí∞ INDIVIDUAL: ${megasNum}MB = ${valorEncontrado}MT`);
            return valorEncontrado;
        }
        
        console.log(`‚ö†Ô∏è INDIVIDUAL: N√£o encontrou pre√ßo para ${megasNum}MB na tabela`);
        return null;
        
    } catch (error) {
        console.error(`‚ùå INDIVIDUAL: Erro ao calcular valor:`, error);
        return null;
    }
}

// === FUN√á√ÉO PARA CALCULAR VALOR ESPERADO BASEADO NO SALDO ===
function calcularValorEsperadoDoSaldo(saldo, grupoId) {
    try {
        const configGrupo = getConfiguracaoGrupo(grupoId);
        if (!configGrupo || !configGrupo.precosSaldo) {
            console.log(`‚ö†Ô∏è SALDO: Grupo ${grupoId} n√£o tem tabela de pre√ßos de saldo configurada`);
            return null;
        }

        // Converter saldo para n√∫mero se for string
        const saldoNum = typeof saldo === 'string' ?
            parseInt(saldo.replace(/[^\d]/g, '')) : parseInt(saldo);

        // Buscar o pre√ßo correspondente na tabela de saldo
        const valorEncontrado = configGrupo.precosSaldo[saldoNum];

        if (valorEncontrado) {
            console.log(`üí∞ SALDO: ${saldoNum}MT = ${valorEncontrado}MT`);
            return valorEncontrado;
        }

        console.log(`‚ö†Ô∏è SALDO: N√£o encontrou pre√ßo para ${saldoNum}MT na tabela de saldo`);
        return null;

    } catch (error) {
        console.error(`‚ùå SALDO: Erro ao calcular valor:`, error);
        return null;
    }
}

// === FUN√á√ÉO PARA ENVIAR PEDIDOS DE SALDO ===
async function enviarSaldoParaTasker(referencia, saldo, numero, grupoId, messageContext = null) {
    const timestamp = new Date().toLocaleString('pt-BR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
    });

    const dadosCompletos = `${referencia}|${saldo}|${numero}|${timestamp}`;

    // Verificar duplicados para saldo
    if (dadosParaTasker.some(d => d.dados === dadosCompletos)) {
        const configGrupo = getConfiguracaoGrupo(grupoId);
        const grupoNome = configGrupo ? configGrupo.nome : 'Grupo Desconhecido';

        if (messageContext) {
            await messageContext.reply(
                `‚ö†Ô∏è *PEDIDO DE SALDO DUPLICADO*\n\n` +
                `üîñ **Refer√™ncia:** ${referencia}\n` +
                `üí∞ **Saldo:** ${saldo}MT\n` +
                `üì± **N√∫mero:** ${numero}\n\n` +
                `‚è∞ **Este pedido j√° foi enviado anteriormente.**\n` +
                `üîÑ **Se houve erro, contacte o administrador.**`
            );
        }

        console.log(`üõë SALDO: Pedido duplicado detectado: ${dadosCompletos}`);
        return null;
    }

    try {
        const configGrupo = getConfiguracaoGrupo(grupoId);
        const grupoNome = configGrupo ? configGrupo.nome : 'Grupo Desconhecido';

        // Salvar no arquivo para Tasker
        await salvarArquivoTasker(dadosCompletos, grupoNome, timestamp);

        // Adicionar aos dados para controle
        dadosParaTasker.push({
            dados: dadosCompletos,
            grupo: grupoNome,
            timestamp: timestamp,
            metodo: 'saldo_tasker',
            tipo: 'saldo'
        });

        // Enviar para Google Sheets (planilha de saldo)
        const resultadoSheets = await enviarSaldoParaGoogleSheets(dadosCompletos, grupoId, timestamp);

        if (messageContext) {
            await messageContext.reply(
                `‚úÖ *PEDIDO DE SALDO CRIADO!*\n\n` +
                `üîñ **Refer√™ncia:** ${referencia}\n` +
                `üí∞ **Saldo:** ${saldo}MT\n` +
                `üì± **N√∫mero:** ${numero}\n` +
                `üè¢ **Grupo:** ${grupoNome}\n\n` +
                `üöÄ **Pedido enviado para processamento!**\n` +
                `üìä **Status Google Sheets:** ${resultadoSheets.sucesso ? '‚úÖ Salvo' : '‚ö†Ô∏è Erro'}`
            );
        }

        console.log(`‚úÖ SALDO: Pedido criado: ${dadosCompletos}`);
        return { sucesso: true, dados: dadosCompletos };

    } catch (error) {
        console.error(`‚ùå SALDO: Erro ao processar:`, error);

        if (messageContext) {
            await messageContext.reply(
                `‚ùå *ERRO AO PROCESSAR SALDO*\n\n` +
                `‚ö†Ô∏è ${error.message}\n\n` +
                `üîß Contacte o administrador se o problema persistir.`
            );
        }

        throw error;
    }
}

// === FUN√á√ÉO PARA ENVIAR SALDO PARA GOOGLE SHEETS ===
async function enviarSaldoParaGoogleSheets(dadosCompletos, grupoId, timestamp) {
    try {
        console.log(`üìä SALDO: Enviando para Google Sheets: ${dadosCompletos}`);

        const payload = {
            grupo_id: grupoId,
            timestamp: timestamp,
            dados: dadosCompletos
        };

        const response = await fetch(GOOGLE_SHEETS_CONFIG_SALDO.scriptUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload),
            timeout: GOOGLE_SHEETS_CONFIG_SALDO.timeout
        });

        if (!response.ok) {
            throw new Error(`Erro HTTP: ${response.status} - ${response.statusText}`);
        }

        const resultado = await response.json();

        if (resultado.success) {
            console.log(`‚úÖ SALDO: Enviado para Google Sheets com sucesso - Linha ${resultado.row}`);
            return { sucesso: true, linha: resultado.row, referencia: resultado.referencia };
        } else {
            console.error(`‚ùå SALDO: Erro no Google Sheets:`, resultado.error || resultado.message);
            return { sucesso: false, erro: resultado.error || resultado.message };
        }

    } catch (error) {
        console.error(`‚ùå SALDO: Erro ao enviar para Google Sheets:`, error);
        return { sucesso: false, erro: error.message };
    }
}

// === FUN√á√ÉO PRINCIPAL PARA TASKER (SEM VERIFICA√á√ÉO - J√Å VERIFICADO ANTES) ===
async function enviarParaTasker(referencia, megas, numero, grupoId, messageContext = null) {
    const timestamp = new Date().toLocaleString('pt-BR', {
        year: 'numeric',
        month: '2-digit', 
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
    });
    
    // CRIAR STRING COM TIMESTAMP NO FINAL
    const dadosCompletos = `${referencia}|${megas}|${numero}|${timestamp}`;
    
    const grupoNome = getConfiguracaoGrupo(grupoId)?.nome || 'Desconhecido';
    
    console.log(`üìä ENVIANDO DADOS (PAGAMENTO J√Å VERIFICADO):`);
    console.log(`   üìã Dados: ${dadosCompletos}`);
    console.log(`   üìç Grupo: ${grupoNome} (${grupoId})`);
    console.log(`   ‚è∞ Timestamp: ${timestamp}`);
    
    // Armazenar localmente (backup)
    dadosParaTasker.push({
        dados: dadosCompletos,
        grupo_id: grupoId,
        grupo: grupoNome,
        timestamp: timestamp,
        enviado: false,
        metodo: 'pendente'
    });
    
    // === ENVIAR PARA GOOGLE SHEETS ===
    const resultado = await enviarParaGoogleSheets(dadosCompletos, grupoId, timestamp);
    
    if (resultado.sucesso) {
        dadosParaTasker[dadosParaTasker.length - 1].enviado = true;
        dadosParaTasker[dadosParaTasker.length - 1].metodo = 'google_sheets';
        dadosParaTasker[dadosParaTasker.length - 1].row = resultado.row;
        console.log(`‚úÖ [${grupoNome}] Enviado para Google Sheets! Row: ${resultado.row}`);
    } else if (resultado.duplicado) {
        // Caso especial: Pagamento duplicado
        console.log(`‚ö†Ô∏è [${grupoNome}] Pagamento DUPLICADO detectado: ${resultado.referencia}`);
        dadosParaTasker[dadosParaTasker.length - 1].metodo = 'duplicado';
        dadosParaTasker[dadosParaTasker.length - 1].status = 'duplicado';
        
        // Notificar no WhatsApp se houver contexto da mensagem
        if (messageContext) {
            try {
                await messageContext.reply(
                    `‚ö†Ô∏è *PAGAMENTO DUPLICADO*\n\n` +
                    `üîç **Refer√™ncia:** ${resultado.referencia}\n` +
                    `üìã Este pagamento j√° foi processado anteriormente\n\n` +
                    `‚úÖ **N√£o √© necess√°rio reenviar**\n` +
                    `üí° O pedido original j√° est√° na fila de processamento`
                );
            } catch (error) {
                console.error(`‚ùå Erro ao enviar notifica√ß√£o de duplicado:`, error);
            }
        }

        // ‚úÖ CONTINUAR PROCESSAMENTO MESMO COM DUPLICADOS
        console.log(`‚ö†Ô∏è DIVIS√ÉO: Pagamento duplicado detectado, mas continuando processamento normal`);
        // Retornar dados normalmente para n√£o quebrar o sistema de divis√£o

    } else {
        console.log(`üîÑ [${grupoNome}] Google Sheets falhou, usando WhatsApp backup...`);
        enviarViaWhatsAppTasker(dadosCompletos, grupoNome);
        dadosParaTasker[dadosParaTasker.length - 1].metodo = 'whatsapp_backup';
    }
    
    await salvarArquivoTasker(dadosCompletos, grupoNome, timestamp);
    
    if (dadosParaTasker.length > 100) {
        dadosParaTasker = dadosParaTasker.slice(-100);
    }
    
    return dadosCompletos;
}

// === FUN√á√ÉO PARA SUBDIVIDIR PEDIDOS INDIVIDUAIS EM BLOCOS DE 10GB ===
async function enviarComSubdivisaoAutomatica(referencia, megasTotal, numero, grupoId, messageContext = null) {
    const LIMITE_MAXIMO_GB = 10240; // 10GB em MB

    console.log(`üîß SUBDIVIS√ÉO INDIVIDUAL: Analisando pedido ${referencia} - ${megasTotal}MB (${megasTotal/1024}GB) para ${numero}`);

    // Se for 10GB ou menos, enviar normalmente
    if (megasTotal <= LIMITE_MAXIMO_GB) {
        console.log(`‚úÖ SUBDIVIS√ÉO: Pedido dentro do limite (${megasTotal/1024}GB ‚â§ 10GB), enviando normalmente`);
        return await enviarParaTasker(referencia, megasTotal, numero, grupoId, messageContext);
    }

    // Calcular quantos blocos de 10GB s√£o necess√°rios
    const numeroBlocos = Math.ceil(megasTotal / LIMITE_MAXIMO_GB);
    console.log(`üîß SUBDIVIS√ÉO: Dividindo ${megasTotal/1024}GB em ${numeroBlocos} blocos de m√°ximo 10GB cada`);

    let megasRestantes = megasTotal;
    let contadorBloco = 1;
    const resultados = [];

    // Criar blocos de exatamente 10GB (exceto o √∫ltimo que pode ser menor)
    while (megasRestantes > 0) {
        const megasDoBloco = megasRestantes >= LIMITE_MAXIMO_GB ? LIMITE_MAXIMO_GB : megasRestantes;
        const referenciaBloco = `${referencia}${String(contadorBloco).padStart(2, '0')}`;

        console.log(`üì¶ SUBDIVIS√ÉO: Bloco ${contadorBloco}/${numeroBlocos}: ${referenciaBloco} - ${megasDoBloco}MB (${megasDoBloco/1024}GB) para ${numero}`);

        try {
            const resultado = await enviarParaTasker(referenciaBloco, megasDoBloco, numero, grupoId, null);
            resultados.push({
                bloco: contadorBloco,
                referencia: referenciaBloco,
                megas: megasDoBloco,
                numero: numero,
                resultado: resultado,
                sucesso: true
            });

            console.log(`‚úÖ SUBDIVIS√ÉO: Bloco ${contadorBloco} criado com sucesso: ${referenciaBloco}`);

        } catch (error) {
            console.error(`‚ùå SUBDIVIS√ÉO: Erro no bloco ${contadorBloco}:`, error.message);
            resultados.push({
                bloco: contadorBloco,
                referencia: referenciaBloco,
                megas: megasDoBloco,
                numero: numero,
                erro: error.message,
                sucesso: false
            });
        }

        megasRestantes -= megasDoBloco;
        contadorBloco++;

        // Pequeno delay entre blocos para n√£o sobrecarregar o sistema
        if (megasRestantes > 0) {
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }

    // Enviar mensagem de resumo se houver contexto
    if (messageContext) {
        const sucessos = resultados.filter(r => r.sucesso).length;
        const erros = resultados.filter(r => !r.sucesso).length;

        let mensagemResumo = `üîß *SUBDIVIS√ÉO AUTOM√ÅTICA*\n\n`;
        mensagemResumo += `üí∞ **Refer√™ncia Original:** ${referencia}\n`;
        mensagemResumo += `üìä **Total:** ${megasTotal/1024}GB dividido em ${numeroBlocos} blocos\n`;
        mensagemResumo += `üì± **N√∫mero:** ${numero}\n\n`;

        if (erros === 0) {
            mensagemResumo += `‚úÖ **${sucessos}/${numeroBlocos} blocos criados com sucesso!**\n\n`;
            mensagemResumo += `üöÄ *O sistema processar√° as transfer√™ncias automaticamente.*`;
        } else {
            mensagemResumo += `‚ö†Ô∏è **Resultado:** ${sucessos} sucessos, ${erros} erros\n\n`;
            mensagemResumo += `üìã **Blocos criados:**\n`;
            resultados.filter(r => r.sucesso).forEach(r => {
                mensagemResumo += `   ‚Ä¢ ${r.referencia}: ${r.megas/1024}GB ‚úÖ\n`;
            });
            if (erros > 0) {
                mensagemResumo += `\n‚ùå **Blocos com erro:**\n`;
                resultados.filter(r => !r.sucesso).forEach(r => {
                    mensagemResumo += `   ‚Ä¢ ${r.referencia}: ${r.megas/1024}GB ‚ùå\n`;
                });
            }
        }

        try {
            await messageContext.reply(mensagemResumo);
            console.log(`üì§ SUBDIVIS√ÉO: Mensagem de resumo enviada - ${sucessos}‚úÖ ${erros}‚ùå`);
        } catch (error) {
            console.error(`‚ùå SUBDIVIS√ÉO: Erro ao enviar mensagem de resumo:`, error.message);
        }
    }

    const sucessoGeral = resultados.every(r => r.sucesso);
    console.log(`üèÅ SUBDIVIS√ÉO: Processo conclu√≠do - ${resultados.filter(r => r.sucesso).length}/${numeroBlocos} blocos criados`);

    return {
        sucesso: sucessoGeral,
        totalBlocos: numeroBlocos,
        blocosProcessados: resultados.length,
        blocosSucesso: resultados.filter(r => r.sucesso).length,
        blocosErro: resultados.filter(r => !r.sucesso).length,
        detalhes: resultados
    };
}

// === FUN√á√ÉO AUXILIAR PARA C√ÅLCULO DE MEGAS ===
// Esta fun√ß√£o deve ser implementada na classe WhatsAppAIAtacado
// Por enquanto, mantemos apenas a estrutura b√°sica

// === FUN√á√ÉO PARA CONVERTER MEGAS ===
function converterMegasParaNumero(megas) {
    if (typeof megas === 'string') {
        // Remover espa√ßos e converter para mai√∫sculas
        const megasLimpo = megas.trim().toUpperCase();
        
        // Padr√µes de convers√£o
        const padroes = [
            { regex: /(\d+(?:\.\d+)?)\s*GB?/i, multiplicador: 1024 },
            { regex: /(\d+(?:\.\d+)?)\s*MB?/i, multiplicador: 1 },
            { regex: /(\d+(?:\.\d+)?)\s*KB?/i, multiplicador: 1/1024 },
            { regex: /(\d+(?:\.\d+)?)\s*TB?/i, multiplicador: 1024 * 1024 }
        ];
        
        for (const padrao of padroes) {
            const match = megasLimpo.match(padrao.regex);
            if (match) {
                const numero = parseFloat(match[1]);
                const resultado = Math.round(numero * padrao.multiplicador);
                console.log(`üîÑ Convers√£o: ${megas} ‚Üí ${resultado} MB`);
                return resultado.toString();
            }
        }
        
        // Se n√£o encontrar padr√£o, tentar extrair apenas n√∫meros
        const apenasNumeros = megasLimpo.replace(/[^\d.]/g, '');
        if (apenasNumeros) {
            console.log(`üîÑ Convers√£o direta: ${megas} ‚Üí ${apenasNumeros} MB`);
            return apenasNumeros;
        }
    }
    
    // Se n√£o conseguir converter, retornar o valor original
    console.log(`‚ö†Ô∏è N√£o foi poss√≠vel converter: ${megas}`);
    return megas;
}

function enviarViaWhatsAppTasker(linhaCompleta, grupoNome, autorMensagem) {
    const item = {
        conteudo: linhaCompleta,
        autor: autorMensagem,
        grupo: grupoNome,
        timestamp: Date.now(),
        id: Date.now() + Math.random(),
        tipo: 'tasker_data_backup_atacado'
    };

    filaMensagens.push(item);
    console.log(`üì± WhatsApp Backup ‚Üí Tasker: ${linhaCompleta}`);

    if (!processandoFila) {
        processarFila();
    }
}

async function salvarArquivoTasker(linhaCompleta, grupoNome, timestamp) {
    try {
        // Arquivo principal para Tasker (apenas a linha)
        await fs.appendFile('tasker_input_atacado.txt', linhaCompleta + '\n');
        
        // Log completo para hist√≥rico
        const logLine = `${timestamp} | ${grupoNome} | ${linhaCompleta}\n`;
        await fs.appendFile('tasker_log_atacado.txt', logLine);
        
        console.log(`üìÅ Arquivo ‚Üí Backup: ${linhaCompleta}`);
        
    } catch (error) {
        console.error('‚ùå Erro ao salvar arquivo Tasker:', error);
    }
}

function obterDadosTasker() {
    return dadosParaTasker;
}

function obterDadosTaskerHoje() {
    const hoje = new Date().toDateString();
    return dadosParaTasker.filter(item => {
        const dataItem = new Date(item.timestamp).toDateString();
        return dataItem === hoje;
    });
}

// === MIDDLEWARE DE PROTE√á√ÉO ===
async function withRetry(operation, maxRetries = 3, delay = 1000) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await operation();
        } catch (error) {
            lastError = error;
            
            if (error.message && error.message.includes('Execution context was destroyed')) {
                console.log(`‚ö†Ô∏è Contexto destru√≠do detectado na tentativa ${attempt}/${maxRetries}`);
                
                if (attempt < maxRetries) {
                    console.log(`üîÑ Aguardando ${delay}ms antes da pr√≥xima tentativa...`);
                    await new Promise(resolve => setTimeout(resolve, delay * attempt));
                    continue;
                }
            }
            
            if (attempt === maxRetries) {
                throw lastError;
            }
            
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
    
    throw lastError;
}

// === FUN√á√ïES AUXILIARES ===

function detectarPerguntaPorNumero(mensagem) {
    const texto = mensagem.toLowerCase();
    
    const padroes = [
        /qual\s+(√©\s+)?(o\s+)?n√∫mero/i,
        /n√∫mero\s+(de\s+)?(contato|suporte|atendimento)/i,
        /como\s+(falar|contactar|entrar em contacto)/i,
        /preciso\s+(de\s+)?(ajuda|suporte|n√∫mero)/i,
        /onde\s+(posso\s+)?falar/i,
        /tem\s+(n√∫mero|contacto|suporte)/i,
        /quero\s+falar\s+com/i,
        /atendimento/i,
        /suporte/i,
        /admin/i,
        /administrador/i,
        /respons√°vel/i,
        /quem\s+(√©\s+)?respons√°vel/i,
        /como\s+contactar/i,
        /n√∫mero\s+do\s+admin/i
    ];
    
    return padroes.some(padrao => padrao.test(texto));
}

function isAdministrador(numero) {
    return ADMINISTRADORES_GLOBAIS.includes(numero);
}

function obterGrupoDoNumero(numeroAdmin) {
    // Extrair apenas o n√∫mero do ID completo (ex: '258840326152@c.us' -> '258840326152')
    const numeroLimpo = numeroAdmin.replace('@c.us', '');
    return MAPEAMENTO_NUMEROS_GRUPOS[numeroLimpo] || null;
}

// === NOVAS FUN√á√ïES PARA SISTEMA DUAL (MEGAS + SALDO) ===

function verificarTipoValor(valor, grupoId) {
    const configGrupo = getConfiguracaoGrupo(grupoId);
    if (!configGrupo) return null;

    // 1. Primeiro verifica se existe na tabela de MEGAS
    if (configGrupo.precos) {
        const valoresValidos = Object.values(configGrupo.precos);
        if (valoresValidos.includes(valor)) {
            // Encontrar quantos megas correspondem a esse valor
            for (const [megas, preco] of Object.entries(configGrupo.precos)) {
                if (preco === valor) {
                    return {
                        tipo: 'megas',
                        quantidade: parseInt(megas),
                        valor: valor,
                        unidade: 'MB'
                    };
                }
            }
        }
    }

    // 2. Se n√£o existe em MEGAS, verifica na tabela de SALDO
    if (configGrupo.precosSaldo) {
        const valoresValidosSaldo = Object.values(configGrupo.precosSaldo);
        if (valoresValidosSaldo.includes(valor)) {
            // Encontrar quanto saldo corresponde a esse valor
            for (const [saldo, preco] of Object.entries(configGrupo.precosSaldo)) {
                if (preco === valor) {
                    return {
                        tipo: 'saldo',
                        quantidade: parseInt(saldo),
                        valor: valor,
                        unidade: 'MT'
                    };
                }
            }
        }
    }

    // 3. Valor n√£o encontrado em nenhuma tabela
    return null;
}

function obterTabelasDisponiveis(grupoId) {
    const configGrupo = getConfiguracaoGrupo(grupoId);
    if (!configGrupo) return { megas: [], saldo: [] };

    const valoresMegas = configGrupo.precos ? Object.values(configGrupo.precos) : [];
    const valoresSaldo = configGrupo.precosSaldo ? Object.values(configGrupo.precosSaldo) : [];

    return {
        megas: valoresMegas,
        saldo: valoresSaldo
    };
}

function isGrupoMonitorado(chatId) {
    return CONFIGURACAO_GRUPOS.hasOwnProperty(chatId);
}

function getConfiguracaoGrupo(chatId) {
    return CONFIGURACAO_GRUPOS[chatId] || null;
}

async function isAdminGrupo(chatId, participantId) {
    try {
        if (adminCache[chatId] && adminCache[chatId].timestamp > Date.now() - 300000) {
            return adminCache[chatId].admins.includes(participantId);
        }

        return await withRetry(async () => {
            const chat = await client.getChatById(chatId);
            if (!chat) {
                console.log(`‚ö†Ô∏è N√£o foi poss√≠vel acessar o chat ${chatId}`);
                return false;
            }

            const participants = await chat.participants || [];
            const admins = participants.filter(p => p.isAdmin || p.isSuperAdmin).map(p => p.id._serialized);
            
            adminCache[chatId] = {
                admins: admins,
                timestamp: Date.now()
            };

            return admins.includes(participantId);
        });
    } catch (error) {
        console.error('‚ùå Erro ao verificar admin do grupo:', error);
        return false;
    }
}

function contemConteudoSuspeito(mensagem) {
    const texto = mensagem.toLowerCase();
    const temLink = /(?:https?:\/\/|www\.|\.com|\.net|\.org|\.br|\.mz|bit\.ly|tinyurl|t\.me|wa\.me|whatsapp\.com|telegram\.me|link|url)/i.test(texto);
    
    return {
        temLink: MODERACAO_CONFIG.detectarLinks && temLink,
        suspeito: MODERACAO_CONFIG.detectarLinks && temLink
    };
}

async function deletarMensagem(message) {
    try {
        await message.delete(true);
        console.log(`üóëÔ∏è Mensagem deletada`);
        return true;
    } catch (error) {
        console.error('‚ùå Erro ao deletar mensagem:', error);
        return false;
    }
}

async function removerParticipante(chatId, participantId, motivo) {
    try {
        const chat = await client.getChatById(chatId);
        await chat.removeParticipants([participantId]);
        console.log(`üö´ Participante removido: ${participantId} - ${motivo}`);
        return true;
    } catch (error) {
        console.error('‚ùå Erro ao remover participante:', error);
        return false;
    }
}

async function aplicarModeracao(message, motivoDeteccao) {
    const chatId = message.from;
    const authorId = message.author || message.from;
    
    try {
        if (!MODERACAO_CONFIG.ativado[chatId]) {
            return;
        }

        if (MODERACAO_CONFIG.excecoes.includes(authorId) || isAdministrador(authorId)) {
            return;
        }

        const isAdmin = await isAdminGrupo(chatId, authorId);
        if (isAdmin) {
            return;
        }

        console.log(`üö® MODERA√á√ÉO: ${motivoDeteccao}`);

        if (MODERACAO_CONFIG.apagarMensagem) {
            await deletarMensagem(message);
        }

        if (MODERACAO_CONFIG.removerUsuario) {
            await removerParticipante(chatId, authorId, motivoDeteccao);
        }

    } catch (error) {
        console.error('‚ùå Erro durante modera√ß√£o:', error);
    }
}

// === DETEC√á√ÉO DE GRUPOS ===
async function logGrupoInfo(chatId, evento = 'detectado') {
    try {
        const chat = await withRetry(async () => {
            return await client.getChatById(chatId);
        }).catch(() => {
            console.log(`‚ö†Ô∏è N√£o foi poss√≠vel acessar informa√ß√µes do grupo ${chatId}`);
            return null;
        });
        
        if (!chat) {
            return null;
        }

        const isGrupoMonitorado = CONFIGURACAO_GRUPOS.hasOwnProperty(chatId);
        
        console.log(`\nüîç ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
        console.log(`üìã GRUPO ${evento.toUpperCase()}`);
        console.log(`üîç ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`);
        console.log(`üìõ Nome: ${chat.name || 'N/A'}`);
        console.log(`üÜî ID: ${chatId}`);
        console.log(`üë• Participantes: ${chat.participants ? chat.participants.length : 'N/A'}`);
        console.log(`üìä Monitorado: ${isGrupoMonitorado ? '‚úÖ SIM' : '‚ùå N√ÉO'}`);
        console.log(`‚è∞ Data: ${new Date().toLocaleString('pt-BR')}`);
        
        if (!isGrupoMonitorado) {
            console.log(`\nüîß PARA ADICIONAR ESTE GRUPO:`);
            console.log(`üìù Copie este c√≥digo para CONFIGURACAO_GRUPOS:`);
            console.log(`\n'${chatId}': {`);
            console.log(`    nome: '${chat.name || 'Nome_do_Grupo'}',`);
            console.log(`    tabela: \`SUA_TABELA_AQUI\`,`);
            console.log(`    pagamento: \`SUAS_FORMAS_DE_PAGAMENTO_AQUI\``);
            console.log(`},\n`);
        }
        
        console.log(`üîç ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`);
        
        return {
            id: chatId,
            nome: chat.name || 'N/A',
            participantes: chat.participants ? chat.participants.length : 0,
            monitorado: isGrupoMonitorado
        };
        
    } catch (error) {
        console.error(`‚ùå Erro ao obter informa√ß√µes do grupo ${chatId}:`, error);
        return null;
    }
}

// === HIST√ìRICO DE COMPRADORES ===

async function carregarHistorico() {
    try {
        const data = await fs.readFile(ARQUIVO_HISTORICO, 'utf8');
        historicoCompradores = JSON.parse(data);
        console.log('üìä Hist√≥rico atacado carregado!');
    } catch (error) {
        console.log('üìä Criando novo hist√≥rico atacado...');
        historicoCompradores = {};
    }
}

async function salvarHistorico() {
    try {
        await fs.writeFile(ARQUIVO_HISTORICO, JSON.stringify(historicoCompradores, null, 2));
        console.log('üíæ Hist√≥rico atacado salvo!');
    } catch (error) {
        console.error('‚ùå Erro ao salvar hist√≥rico:', error);
    }
}

async function registrarComprador(grupoId, numeroComprador, nomeContato, megas) {
    const agora = new Date();
    const timestamp = agora.toISOString();

    if (!historicoCompradores[grupoId]) {
        historicoCompradores[grupoId] = {
            nomeGrupo: getConfiguracaoGrupo(grupoId)?.nome || 'Grupo Desconhecido',
            compradores: {}
        };
    }

    if (!historicoCompradores[grupoId].compradores[numeroComprador]) {
        historicoCompradores[grupoId].compradores[numeroComprador] = {
            primeiraCompra: timestamp,
            ultimaCompra: timestamp,
            totalCompras: 1,
            nomeContato: nomeContato,
            historico: []
        };
    } else {
        historicoCompradores[grupoId].compradores[numeroComprador].ultimaCompra = timestamp;
        historicoCompradores[grupoId].compradores[numeroComprador].totalCompras++;
        historicoCompradores[grupoId].compradores[numeroComprador].nomeContato = nomeContato;
    }

    historicoCompradores[grupoId].compradores[numeroComprador].historico.push({
        data: timestamp,
        megas: megas
    });

    if (historicoCompradores[grupoId].compradores[numeroComprador].historico.length > 10) {
        historicoCompradores[grupoId].compradores[numeroComprador].historico =
            historicoCompradores[grupoId].compradores[numeroComprador].historico.slice(-10);
    }

    await salvarHistorico();
    console.log(`üí∞ Comprador atacado registrado: ${nomeContato} (${numeroComprador}) - ${megas}`);
}

// === FILA DE MENSAGENS ===

function adicionarNaFila(mensagem, autor, nomeGrupo, timestamp) {
    const item = {
        conteudo: mensagem,
        autor: autor,
        grupo: nomeGrupo,
        timestamp: timestamp,
        id: Date.now() + Math.random()
    };

    filaMensagens.push(item);
    console.log(`üì• Adicionado √† fila: ${filaMensagens.length} mensagens`);

    if (!processandoFila) {
        processarFila();
    }
}

async function processarFila() {
    if (processandoFila || filaMensagens.length === 0) {
        return;
    }

    processandoFila = true;
    console.log(`üöÄ Processando ${filaMensagens.length} mensagens...`);

    while (filaMensagens.length > 0) {
        const item = filaMensagens.shift();

        try {
            await withRetry(async () => {
                await client.sendMessage(ENCAMINHAMENTO_CONFIG.numeroDestino, item.conteudo);
            });
            
            console.log(`‚úÖ Encaminhado: ${item.conteudo.substring(0, 50)}...`);

            if (filaMensagens.length > 0) {
                await new Promise(resolve => setTimeout(resolve, ENCAMINHAMENTO_CONFIG.intervaloSegundos * 1000));
            }

        } catch (error) {
            console.error(`‚ùå Erro ao encaminhar:`, error);
            filaMensagens.unshift(item);
            await new Promise(resolve => setTimeout(resolve, 10000));
        }
    }

    processandoFila = false;
    console.log(`üéâ Fila processada!`);
}

// === EVENTOS DO BOT ===

client.on('qr', (qr) => {
    console.log('üì± BOT ATACADO - Escaneie o QR Code:');
    qrcode.generate(qr, { small: true });
});

client.on('ready', async () => {
    console.log('‚úÖ Event ready fired! Bot ATACADO conectado e pronto!');
    console.log('üß† IA WhatsApp ATACADO ativa!');
    console.log('üì¶ Sistema inteligente: C√°lculo autom√°tico de megas!');
    console.log('üìä Google Sheets ATACADO configurado!');
    console.log('üîÑ Bot de Divis√£o ATIVO - M√∫ltiplos n√∫meros autom√°tico!');
    console.log(`üîó URL: ${GOOGLE_SHEETS_CONFIG_ATACADO.scriptUrl}`);
    
    await carregarHistorico();
    
    console.log('\nü§ñ Monitorando grupos ATACADO:');
    Object.keys(CONFIGURACAO_GRUPOS).forEach(grupoId => {
        const config = CONFIGURACAO_GRUPOS[grupoId];
        console.log(`   üìã ${config.nome} (${grupoId})`);
    });
    
    console.log('\nüîß Comandos admin: .ia .divisao .test_busca .stats .sheets .test_sheets .test_grupo .grupos_status .grupos .grupo_atual .debug_grupo .pedido');
});

client.on('group-join', async (notification) => {
    try {
        const chatId = notification.chatId;
        
        // Detectar se o bot foi adicionado
        const addedParticipants = notification.recipientIds || [];
        try {
            const botInfo = await client.info;
            
            if (botInfo && addedParticipants.includes(botInfo.wid._serialized)) {
                console.log(`\nü§ñ BOT ATACADO ADICIONADO A UM NOVO GRUPO!`);
                await logGrupoInfo(chatId, 'BOT ATACADO ADICIONADO');
            
            setTimeout(async () => {
                try {
                    const isMonitorado = CONFIGURACAO_GRUPOS.hasOwnProperty(chatId);
                    const mensagem = isMonitorado ? 
                        `ü§ñ *BOT ATACADO ATIVO E CONFIGURADO!*\n\nEste grupo est√° monitorado e o sistema autom√°tico j√° est√° funcionando.\n\nüìã Digite: *tabela* (ver pre√ßos)\nüí≥ Digite: *pagamento* (ver formas)\n\n‚ö†Ô∏è *ATACADO: C√°lculo autom√°tico de megas*` :
                        `ü§ñ *BOT ATACADO CONECTADO!*\n\n‚öôÔ∏è Este grupo ainda n√£o est√° configurado.\nüîß Contacte o administrador para ativa√ß√£o.\n\nüìù ID do grupo copiado no console do servidor.`;
                    
                    await client.sendMessage(chatId, mensagem);
                    console.log(`‚úÖ Mensagem de status enviada`);
                } catch (error) {
                    console.error('‚ùå Erro ao enviar mensagem de status:', error);
                }
            }, 3000);
            }
        } catch (error) {
            console.error('‚ùå Erro ao verificar info do bot:', error);
        }
        
        // C√≥digo original do grupo j√° configurado
        const configGrupo = getConfiguracaoGrupo(chatId);
        if (configGrupo) {
            console.log(`üëã Novo membro no grupo ${configGrupo.nome}`);
            
            const mensagemBoasVindas = `
ÔøΩÔøΩ *SISTEMA ATACADO - C√ÅLCULO AUTOM√ÅTICO DE MEGAS* 

Bem-vindo(a) ao *${configGrupo.nome}*! 

‚ú® *Aqui usamos sistema atacado inteligente!*

üõí *Como comprar:*
1Ô∏è‚É£ Fa√ßa o pagamento 
2Ô∏è‚É£ Envie comprovante + UM n√∫mero
3Ô∏è‚É£ Sistema calcula megas automaticamente!
4Ô∏è‚É£ Receba megas no n√∫mero!

üìã Digite: *tabela* (ver pre√ßos)
üí≥ Digite: *pagamento* (ver formas)

‚ö° *C√°lculo autom√°tico baseado na tabela!*
            `;
            
            setTimeout(async () => {
                try {
                    await client.sendMessage(chatId, mensagemBoasVindas);
                    console.log(`‚úÖ Mensagem de boas-vindas enviada`);
                } catch (error) {
                    console.error('‚ùå Erro ao enviar boas-vindas:', error);
                }
            }, 2000);
        }
    } catch (error) {
        console.error('‚ùå Erro no evento group-join:', error);
    }
});

client.on('message', async (message) => {
    try {
        const isPrivado = !message.from.endsWith('@g.us');
        const isAdmin = isAdministrador(message.from);

        // === COMANDOS ADMINISTRATIVOS ===
        if (isAdmin) {
            const mensagemOriginal = message.body.trim();
            const comando = mensagemOriginal.toLowerCase();

            if (comando === '.ia') {
                const statusIA = ia.getStatusDetalhado();
                await message.reply(statusIA);
                console.log(`üß† Comando .ia executado`);
                return;
            }

            // NOVO COMANDO: Status do bot de divis√£o
            if (comando === '.divisao') {
                const status = botDivisao.getStatus();
                const resposta = `üîÑ *BOT DE DIVIS√ÉO STATUS*\n` +
                    `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n` +
                    `üíæ Comprovativos memorizados: ${status.comprovantesMemorizados}\n` +
                    `‚ö° Divis√µes em processamento: ${status.processandoDivisoes}\n` +
                    `üè¢ Grupos configurados: ${status.gruposConfigurados}\n\n` +
                    `‚úÖ Sistema ativo e funcionando!`;
                
                await message.reply(resposta);
                return;
            }
            
            // NOVO COMANDO: Testar busca de pagamento
            if (comando.startsWith('.test_busca ')) {
                const parametros = mensagemOriginal.replace(/^\.test_busca\s+/i, '').split(' ');
                if (parametros.length >= 2) {
                    const referencia = parametros[0];
                    const valor = parseFloat(parametros[1]);
                    
                    console.log(`üß™ Testando busca: ${referencia} - ${valor}MT`);
                    
                    const resultado = await botDivisao.buscarPagamentoNaPlanilha(referencia, valor);
                    
                    const resposta = resultado ? 
                        `‚úÖ *PAGAMENTO ENCONTRADO*\n\nüîç Refer√™ncia: ${referencia}\nüí∞ Valor: ${valor}MT` :
                        `‚ùå *PAGAMENTO N√ÉO ENCONTRADO*\n\nüîç Refer√™ncia: ${referencia}\nüí∞ Valor: ${valor}MT`;
                    
                    await message.reply(resposta);
                } else {
                    await message.reply('‚ùå Uso: .test_busca REFERENCIA VALOR\nExemplo: .test_busca CHP4H5DMI1S 375');
                }
                return;
            }

            if (comando === '.stats') {
                let stats = `üìä *ESTAT√çSTICAS ATACADO*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                
                Object.keys(CONFIGURACAO_GRUPOS).forEach(grupoId => {
                    const config = CONFIGURACAO_GRUPOS[grupoId];
                    const dados = historicoCompradores[grupoId];
                    const totalCompradores = dados ? Object.keys(dados.compradores || {}).length : 0;
                    
                    if (totalCompradores > 0) {
                        stats += `üè¢ *${config.nome}*\n`;
                        stats += `üë• ${totalCompradores} compradores\n\n`;
                    }
                });
                
                await message.reply(stats);
                return;
            }

            // === COMANDOS GOOGLE SHEETS ===
            if (comando === '.test_sheets') {
                console.log(`üß™ Testando Google Sheets...`);
                
                const resultado = await enviarParaGoogleSheets('TEST123|1250|842223344|' + new Date().toLocaleString('pt-BR'), 'test_group', new Date().toLocaleString('pt-BR'));
                
                if (resultado.sucesso) {
                    await message.reply(`‚úÖ *Google Sheets funcionando!*\n\nüìä URL: ${GOOGLE_SHEETS_CONFIG.scriptUrl}\nüìù Row: ${resultado.row}\nüéâ Dados enviados com sucesso!`);
                } else {
                    await message.reply(`‚ùå *Google Sheets com problema!*\n\nüìä URL: ${GOOGLE_SHEETS_CONFIG.scriptUrl}\n‚ö†Ô∏è Erro: ${resultado.erro}\n\nüîß *Verifique:*\n‚Ä¢ Script publicado corretamente\n‚Ä¢ Permiss√µes do Google Sheets\n‚Ä¢ Internet funcionando`);
                }
                return;
            }

            if (comando === '.test_grupo') {
                const grupoAtual = message.from;
                const configGrupo = getConfiguracaoGrupo(grupoAtual);
                
                if (!configGrupo) {
                    await message.reply('‚ùå Este grupo n√£o est√° configurado!');
                    return;
                }
                
                console.log(`üß™ Testando Google Sheets para grupo: ${configGrupo.nome}`);
                
                const resultado = await enviarParaGoogleSheets('TEST999|1250|847777777|' + new Date().toLocaleString('pt-BR'), grupoAtual, new Date().toLocaleString('pt-BR'));
                
                if (resultado.sucesso) {
                    await message.reply(`‚úÖ *Teste enviado para ${configGrupo.nome}!*\n\nüìä Row: ${resultado.row}\nüîç O celular deste grupo deve processar em at√© 30 segundos.\n\nüì± *Grupo ID:* \`${grupoAtual}\``);
                } else {
                    await message.reply(`‚ùå *Erro no teste:* ${resultado.erro}`);
                }
                return;
            }

            if (comando === '.grupos_status') {
                let resposta = `üìä *STATUS DOS GRUPOS ATACADO*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                
                for (const [grupoId, config] of Object.entries(CONFIGURACAO_GRUPOS)) {
                    const dadosGrupo = dadosParaTasker.filter(d => d.grupo_id === grupoId);
                    const hoje = dadosGrupo.filter(d => {
                        const dataItem = new Date(d.timestamp).toDateString();
                        return dataItem === new Date().toDateString();
                    });
                    
                    resposta += `üè¢ *${config.nome}*\n`;
                    resposta += `   üìà Total: ${dadosGrupo.length}\n`;
                    resposta += `   üìÖ Hoje: ${hoje.length}\n`;
                    resposta += `   üìä Sheets: ${dadosGrupo.filter(d => d.metodo === 'google_sheets').length}\n`;
                    resposta += `   üì± Backup: ${dadosGrupo.filter(d => d.metodo === 'whatsapp_backup').length}\n`;
                    resposta += `   üÜî ID: \`${grupoId}\`\n\n`;
                }
                
                await message.reply(resposta);
                return;
            }

            if (comando === '.sheets') {
                const dados = obterDadosTasker();
                const hoje = obterDadosTaskerHoje();
                const sheets = dados.filter(d => d.metodo === 'google_sheets').length;
                const whatsapp = dados.filter(d => d.metodo === 'whatsapp_backup').length;
                
                let resposta = `üìä *GOOGLE SHEETS STATUS ATACADO*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                resposta += `üìà Total enviado: ${dados.length}\n`;
                resposta += `üìÖ Hoje: ${hoje.length}\n`;
                resposta += `üìä Via Google Sheets: ${sheets}\n`;
                resposta += `üì± Via WhatsApp: ${whatsapp}\n`;
                resposta += `üì± Fila atual: ${filaMensagens.length}\n\n`;
                
                if (dados.length > 0) {
                    resposta += `üìã *√öltimos 5 enviados:*\n`;
                    dados.slice(-5).forEach((item, index) => {
                        const metodo = item.metodo === 'google_sheets' ? 'üìä' : 'üì±';
                        resposta += `${index + 1}. ${metodo} ${item.dados} (${item.grupo})\n`;
                    });
                }
                
                await message.reply(resposta);
                return;
            }

            if (comando.startsWith('.clear_grupo ')) {
                const nomeGrupo = mensagemOriginal.replace(/^\.clear_grupo\s+/i, '');
                const antes = dadosParaTasker.length;
                
                dadosParaTasker = dadosParaTasker.filter(d => !d.grupo.toLowerCase().includes(nomeGrupo.toLowerCase()));
                
                const removidos = antes - dadosParaTasker.length;
                await message.reply(`üóëÔ∏è *${removidos} registros do grupo "${nomeGrupo}" removidos!*`);
                return;
            }

            if (comando === '.clear_sheets') {
                dadosParaTasker = [];
                await message.reply('üóëÔ∏è *Dados do Google Sheets atacado limpos!*');
                return;
            }

            // === COMANDOS PARA DETEC√á√ÉO DE GRUPOS ===
            if (comando === '.grupos') {
                try {
                    let resposta = `üìã *GRUPOS CONFIGURADOS ATACADO*\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

                    // Mostrar grupo padr√£o do admin (se existir)
                    const meuGrupo = obterGrupoDoNumero(message.from);
                    if (meuGrupo) {
                        const configMeuGrupo = getConfiguracaoGrupo(meuGrupo);
                        resposta += `üè† *SEU GRUPO PADR√ÉO:*\n`;
                        resposta += `üìã ${configMeuGrupo.nome}\n`;
                        resposta += `üÜî ${meuGrupo}\n\n`;
                    }

                    resposta += `üìä *TODOS OS GRUPOS:*\n`;
                    Object.keys(CONFIGURACAO_GRUPOS).forEach(grupoId => {
                        const config = CONFIGURACAO_GRUPOS[grupoId];
                        const isMeuGrupo = meuGrupo === grupoId ? ' ‚≠ê' : '';
                        resposta += `üìã ${config.nome}${isMeuGrupo}\n`;
                        resposta += `üÜî \`${grupoId}\`\n\n`;
                    });

                    resposta += `üí° *MAPEAMENTO DE ADMINS:*\n`;
                    Object.keys(MAPEAMENTO_NUMEROS_GRUPOS).forEach(numero => {
                        const grupoId = MAPEAMENTO_NUMEROS_GRUPOS[numero];
                        const config = getConfiguracaoGrupo(grupoId);
                        resposta += `üì± ${numero} ‚Üí ${config.nome}\n`;
                    });

                    const chats = await client.getChats();
                    const grupos = chats.filter(chat => chat.isGroup);
                    
                    resposta += `üìä Total de grupos: ${grupos.length}\n\n`;
                    
                    for (const grupo of grupos) {
                        const isMonitorado = CONFIGURACAO_GRUPOS.hasOwnProperty(grupo.id._serialized);
                        const status = isMonitorado ? '‚úÖ' : '‚ùå';
                        
                        resposta += `${status} *${grupo.name}*\n`;
                        resposta += `   üÜî \`${grupo.id._serialized}\`\n`;
                        resposta += `   üë• ${grupo.participants.length} membros\n\n`;
                    }
                    
                    resposta += `\nüîß *Para adicionar grupo:*\nCopie ID e adicione em CONFIGURACAO_GRUPOS`;
                    
                    await message.reply(resposta);
                    
                    console.log(`\nüìã COMANDO .grupos executado - ${grupos.length} grupos encontrados`);
                    grupos.forEach(grupo => {
                        const isMonitorado = CONFIGURACAO_GRUPOS.hasOwnProperty(grupo.id._serialized);
                        console.log(`${isMonitorado ? '‚úÖ' : '‚ùå'} ${grupo.name}: ${grupo.id._serialized}`);
                    });
                    
                } catch (error) {
                    console.error('‚ùå Erro ao listar grupos:', error);
                    await message.reply('‚ùå Erro ao obter lista de grupos');
                }
                return;
            }

            if (comando === '.grupo_atual') {
                if (!message.from.endsWith('@g.us')) {
                    await message.reply('‚ùå Use este comando em um grupo!');
                    return;
                }
                
                await logGrupoInfo(message.from, 'COMANDO .grupo_atual');
                
                const configGrupo = getConfiguracaoGrupo(message.from);
                const status = configGrupo ? '‚úÖ CONFIGURADO' : '‚ùå N√ÉO CONFIGURADO';
                
                await message.reply(
                    `üìã *INFORMA√á√ïES DESTE GRUPO ATACADO*\n\n` +
                    `üÜî ID: \`${message.from}\`\n` +
                    `üìä Status: ${status}\n\n` +
                    `${configGrupo ? `üè¢ Nome: ${configGrupo.nome}` : 'üîß Precisa ser configurado'}\n\n` +
                    `üìù Verifique o console para detalhes completos`
                );
                return;
            }

            // NOVO COMANDO: Verificar IDs dos grupos atuais
            if (comando === '.debug_grupo') {
                const grupoInfo = {
                    id: message.from,
                    isGrupo: message.from.endsWith('@g.us'),
                    isMonitorado: isGrupoMonitorado(message.from),
                    configExiste: !!getConfiguracaoGrupo(message.from)
                };
                
                await message.reply(
                    `üîç *DEBUG GRUPO*\n\n` +
                    `üÜî ID: \`${grupoInfo.id}\`\n` +
                    `üì± √â grupo: ${grupoInfo.isGrupo ? '‚úÖ' : '‚ùå'}\n` +
                    `üìä Monitorado: ${grupoInfo.isMonitorado ? '‚úÖ' : '‚ùå'}\n` +
                    `‚öôÔ∏è Config existe: ${grupoInfo.configExiste ? '‚úÖ' : '‚ùå'}\n\n` +
                    `üìã *Grupos configurados:*\n${Object.keys(CONFIGURACAO_GRUPOS).join('\n')}`
                );
                return;
            }

            // NOVO COMANDO: .pedido - Permite ao admin criar pedidos diretamente (APENAS PRIVADO)
            if (comando.startsWith('.pedido ')) {
                // Verificar se est√° sendo usado no privado
                if (!isPrivado) {
                    await message.reply('‚ùå Este comando s√≥ pode ser usado no chat privado!\n\nüîí Mande uma mensagem privada para o bot para usar este comando.');
                    return;
                }

                const parametros = mensagemOriginal.replace(/^\.pedido\s+/i, '').trim();
                const partes = parametros.split(' ');

                if (partes.length < 3) {
                    await message.reply(
                        `‚ùå *Uso do comando .pedido*\n\n` +
                        `üìù **Formato:** .pedido REFERENCIA MEGAS NUMERO [GRUPO_ID]\n\n` +
                        `üí° **Exemplos:**\n` +
                        `‚Ä¢ .pedido ADMIN001 10240 847777777\n` +
                        `‚Ä¢ .pedido PROMO123 20480 848888888 120363419652375064@g.us\n\n` +
                        `üìä **MEGAS em MB:** 10240 = 10GB, 20480 = 20GB, etc.\n` +
                        `üè¢ **GRUPO_ID:** Opcional - se n√£o informado, usa seu grupo padr√£o\n` +
                        `üí° Use .grupos para ver IDs dispon√≠veis`
                    );
                    return;
                }

                const [referencia, megas, numero, grupoIdManual] = partes;

                // Determinar o grupo: manual ou autom√°tico baseado no admin
                let grupoId;
                if (grupoIdManual) {
                    grupoId = grupoIdManual;
                } else {
                    grupoId = obterGrupoDoNumero(message.from);
                    if (!grupoId) {
                        await message.reply(
                            `‚ùå *Grupo n√£o configurado para seu n√∫mero!*\n\n` +
                            `üîß Voc√™ precisa especificar o GRUPO_ID manualmente:\n` +
                            `üìù .pedido ${referencia} ${megas} ${numero} GRUPO_ID\n\n` +
                            `üí° Use .grupos para ver grupos dispon√≠veis`
                        );
                        return;
                    }
                }

                const configGrupo = getConfiguracaoGrupo(grupoId);

                // Verificar se o grupo est√° configurado
                if (!configGrupo) {
                    await message.reply('‚ùå Grupo n√£o configurado no sistema!\n\nüí° Use .grupos para ver grupos dispon√≠veis.');
                    return;
                }

                // Validar formato dos par√¢metros
                const megasNum = parseInt(megas);
                if (isNaN(megasNum) || megasNum <= 0) {
                    await message.reply('‚ùå Megas deve ser um n√∫mero positivo (ex: 10240 para 10GB)');
                    return;
                }

                // Validar n√∫mero de telefone
                if (!/^\d{9,12}$/.test(numero)) {
                    await message.reply('‚ùå N√∫mero inv√°lido! Use formato: 847777777 ou 258847777777');
                    return;
                }

                const grupoTipo = grupoIdManual ? 'manual' : 'autom√°tico';
                console.log(`üîß ADMIN: Comando .pedido executado pelo admin no privado`);
                console.log(`   üìã Refer√™ncia: ${referencia}`);
                console.log(`   üìä Megas: ${megasNum} (${Math.floor(megasNum/1024)}GB)`);
                console.log(`   üì± N√∫mero: ${numero}`);
                console.log(`   üè¢ Grupo: ${configGrupo.nome} (${grupoTipo})`);
                console.log(`   üÜî ID: ${grupoId}`);

                try {
                    // Enviar pedido direto para o sistema
                    const resultadoEnvio = await enviarParaTasker(
                        referencia,
                        megasNum,
                        numero,
                        grupoId,
                        message
                    );

                    if (resultadoEnvio === null) {
                        console.log(`üõë ADMIN: Pedido duplicado detectado`);
                        return; // Mensagem de duplicado j√° foi enviada
                    }

                    // Registrar no hist√≥rico
                    const nomeAdmin = message._data.notifyName || 'Admin';
                    await registrarComprador(grupoId, numero, `${nomeAdmin} (Admin)`, megasNum);

                    // Resposta de sucesso
                    await message.reply(
                        `‚úÖ *PEDIDO ADMINISTRATIVO CRIADO!*\n\n` +
                        `üí∞ **Refer√™ncia:** ${referencia}\n` +
                        `üìä **Megas:** ${Math.floor(megasNum/1024)}GB (${megasNum}MB)\n` +
                        `üì± **N√∫mero:** ${numero}\n` +
                        `üè¢ **Grupo:** ${configGrupo.nome}\n\n` +
                        `‚è≥ *O sistema ir√° processar em instantes...*`
                    );

                    console.log(`‚úÖ ADMIN: Pedido administrativo criado com sucesso!`);

                } catch (error) {
                    console.error(`‚ùå ADMIN: Erro ao criar pedido:`, error);
                    await message.reply(
                        `‚ùå *Erro ao criar pedido administrativo*\n\n` +
                        `‚ö†Ô∏è ${error.message}\n\n` +
                        `üîß Tente novamente ou contacte o suporte t√©cnico.`
                    );
                }
                return;
            }
        }

        // === DETEC√á√ÉO DE GRUPOS N√ÉO CONFIGURADOS ===
        if (message.from.endsWith('@g.us') && !isGrupoMonitorado(message.from) && !message.fromMe) {
            if (!gruposLogados.has(message.from)) {
                await logGrupoInfo(message.from, 'MENSAGEM RECEBIDA');
                gruposLogados.add(message.from);
                
                // Limpar cache a cada 50 grupos para evitar memory leak
                if (gruposLogados.size > 50) {
                    gruposLogados.clear();
                }
            }
        }

        // === COMANDOS B√ÅSICOS (PARA TODAS AS MENSAGENS) ===
        const textoMensagem = message.body ? message.body.toLowerCase().trim() : '';
        
        if (textoMensagem === 'teste') {
            await message.reply('ü§ñ Bot funcionando normalmente!');
            return;
        }
        
        if (textoMensagem === 'tabela') {
            const configGrupoBasico = getConfiguracaoGrupo(message.from);
            if (configGrupoBasico && configGrupoBasico.tabela) {
                await message.reply(configGrupoBasico.tabela);
            } else {
                await message.reply('‚ùå Tabela n√£o configurada para este grupo.');
            }
            return;
        }
        
        if (textoMensagem === 'pagamento') {
            const configGrupoBasico = getConfiguracaoGrupo(message.from);
            if (configGrupoBasico && configGrupoBasico.pagamento) {
                await message.reply(configGrupoBasico.pagamento);
            } else {
                await message.reply('‚ùå Informa√ß√µes de pagamento n√£o configuradas para este grupo.');
            }
            return;
        }

        // === PROCESSAMENTO DE GRUPOS ===
        if (!message.from.endsWith('@g.us') || !isGrupoMonitorado(message.from)) {
            return;
        }

        const configGrupo = getConfiguracaoGrupo(message.from);
        if (!configGrupo || message.fromMe) {
            return;
        }

        // === MODERA√á√ÉO ===
        if (message.type === 'chat') {
            const analise = contemConteudoSuspeito(message.body);
            
            if (analise.suspeito) {
                console.log(`üö® Conte√∫do suspeito detectado`);
                await aplicarModeracao(message, "Link detectado");
                return;
            }
        }

        // === PROCESSAMENTO DE IMAGENS REMOVIDO ===
        if (message.type === 'image') {
            await message.reply(
                '‚ùå Processamento de imagens desativado\n' +
                'üìÑ Solicitamos que o comprovante seja enviado em formato de texto.\n\n' +
                '‚ÑπÔ∏è Esta medida foi adotada para garantir que o sistema funcione de forma mais r√°pida, est√°vel e com menos falhas.'
            );
            return;
        }

        if (message.type !== 'chat') {
            return;
        }

        // TESTE SIMPLES - Comando de teste
        if (/^!teste$/i.test(message.body)) {
            await message.reply(`‚úÖ Bot funcionando! Grupo: ${configGrupo.nome}`);
            return;
        }

        // Comandos de tabela e pagamento
        if (/tabela/i.test(message.body)) {
            await message.reply(configGrupo.tabela);
            return;
        }

        if (/pagamento/i.test(message.body)) {
            await message.reply(configGrupo.pagamento);
            return;
        }

        // === DETEC√á√ÉO DE PERGUNTA POR N√öMERO (N√ÉO-ADMIN) ===
        if (!isAdmin && detectarPerguntaPorNumero(message.body)) {
            console.log(`üì± Pergunta por n√∫mero detectada de n√£o-admin`);
            await message.reply(
                `üì± *Para solicitar n√∫mero ou suporte:*\n\n` +
                `üí≥ *Primeiro fa√ßa o pagamento:*\n\n` +
                `${configGrupo.pagamento}\n\n` +
                `üìù *Depois envie:*\n` +
                `‚Ä¢ Comprovante de pagamento\n` +
                `‚Ä¢ UM n√∫mero que vai receber\n\n` +
                `ü§ñ *Sistema atacado - valor integral!*`
            );
            return;
        }

        // === BOT DE DIVIS√ÉO (ANTES DA IA) ===
        const remetente = message.author || message.from;
        const resultadoDivisao = await botDivisao.processarMensagem(message, remetente, message.from);
        
        if (resultadoDivisao) {
            console.log('üîÑ DIVIS√ÉO: Mensagem processada pelo bot de divis√£o');
            
            // Se o bot de divis√£o retornou uma resposta, enviar
            if (resultadoDivisao.resposta) {
                await message.reply(resultadoDivisao.resposta);
            }
            
            // Se foi processado com sucesso, n√£o continuar para o bot original
            if (resultadoDivisao.processado) {
                if (resultadoDivisao.duplicados > 0) {
                    console.log(`‚úÖ DIVIS√ÉO: ${resultadoDivisao.sucessos}/${resultadoDivisao.total} pedidos criados, ${resultadoDivisao.duplicados} duplicados`);
                } else {
                    console.log(`‚úÖ DIVIS√ÉO: ${resultadoDivisao.sucessos}/${resultadoDivisao.total} pedidos criados`);
                }
                return; // IMPORTANTE: Sair aqui, n√£o processar no bot original
            }
            
            // Se retornou uma resposta mas n√£o foi processado, tamb√©m sair
            if (resultadoDivisao.resposta) {
                return;
            }
        }

        // === PROCESSAMENTO COM IA ===
        const resultadoIA = await ia.processarMensagemBot(message.body, remetente, 'texto', configGrupo);
        
        if (resultadoIA.erro) {
            console.error(`‚ùå Erro na IA:`, resultadoIA.mensagem);
            return;
        }

        if (resultadoIA.sucesso) {
            
            if (resultadoIA.tipo === 'comprovante_recebido') {
                // Detectar se √© saldo ou megas baseado no que a IA retornou
                const isSaldoComprovante = resultadoIA.tipoProduto === 'saldo';
                const produtoTexto = isSaldoComprovante ? `${resultadoIA.saldo || resultadoIA.megas}MT` : resultadoIA.megas;
                const tipoProdutoTexto = isSaldoComprovante ? 'Saldo' : 'Megas';

                await message.reply(
                    `‚úÖ *Comprovante processado!*\n\n` +
                    `üí∞ Refer√™ncia: ${resultadoIA.referencia}\n` +
                    `üìä ${tipoProdutoTexto}: ${produtoTexto}\n\n` +
                    `üì± *Envie UM n√∫mero que vai receber ${produtoTexto}!*`
                );
                return;
                
            } else if (resultadoIA.tipo === 'numero_processado' || resultadoIA.tipo === 'saldo_processado') {
                const dadosCompletos = resultadoIA.dadosCompletos;
                const [referencia, produto, numero] = dadosCompletos.split('|');
                const nomeContato = message._data.notifyName || 'N/A';
                const autorMensagem = message.author || 'Desconhecido';

                // Verificar se √© saldo ou megas
                const isSaldo = resultadoIA.tipo === 'saldo_processado';

                // Converter produto para formato num√©rico (megas ou saldo)
                const produtoConvertido = isSaldo ? parseInt(produto) : converterMegasParaNumero(produto);
                
                // === NOVA VERIFICA√á√ÉO: CONFIRMAR PAGAMENTO ANTES DE PROCESSAR ===
                console.log(`üîç INDIVIDUAL: Verificando pagamento antes de processar texto (${isSaldo ? 'SALDO' : 'MEGAS'})...`);

                // 1. Usar valor do comprovante se dispon√≠vel, sen√£o calcular
                let valorEsperado;
                if (resultadoIA.valorPago && resultadoIA.valorPago > 0) {
                    // Se a IA extraiu o valor do comprovante, usar esse valor
                    valorEsperado = normalizarValor(resultadoIA.valorPago);
                    console.log(`üí∞ INDIVIDUAL: Usando valor do comprovante: ${valorEsperado}MT`);
                } else {
                    // Sen√£o, calcular baseado no tipo (saldo ou megas)
                    valorEsperado = isSaldo ?
                        calcularValorEsperadoDoSaldo(produtoConvertido, message.from) :
                        calcularValorEsperadoDosMegas(produtoConvertido, message.from);
                    console.log(`üí∞ INDIVIDUAL: Calculando valor baseado no ${isSaldo ? 'saldo' : 'megas'}: ${valorEsperado}MT`);
                }
                
                if (!valorEsperado) {
                    console.log(`‚ö†Ô∏è INDIVIDUAL: N√£o foi poss√≠vel calcular valor, processando sem verifica√ß√£o`);

                    if (isSaldo) {
                        // Processar saldo
                        await enviarSaldoParaTasker(referencia, produtoConvertido, numero, message.from, message);
                        await registrarComprador(message.from, numero, nomeContato, produtoConvertido);
                    } else {
                        // Processar megas
                        await enviarComSubdivisaoAutomatica(referencia, produtoConvertido, numero, message.from, message);
                        await registrarComprador(message.from, numero, nomeContato, resultadoIA.valorPago || produto);
                    }
                    
                    if (message.from === ENCAMINHAMENTO_CONFIG.grupoOrigem) {
                        const timestampMensagem = new Date().toLocaleString('pt-BR');
                        adicionarNaFila(dadosCompletos, autorMensagem, configGrupo.nome, timestampMensagem);
                    }
                    
                    const tipoProdutoTexto = isSaldo ? 'Saldo' : 'Megas';
                    const produtoTexto = isSaldo ? `${produtoConvertido}MT` : produto;

                    await message.reply(
                        `‚úÖ *Pedido processado!*\n\n` +
                        `üí∞ Refer√™ncia: ${referencia}\n` +
                        `üìä ${tipoProdutoTexto}: ${produtoTexto}\n` +
                        `üì± N√∫mero: ${numero}\n\n` +
                        `‚è≥ *Aguarde uns instantes enquanto o sistema executa a transfer√™ncia*`
                    );
                    return;
                }
                
                // 2. Verificar se pagamento existe
                const pagamentoConfirmado = await verificarPagamentoIndividual(referencia, valorEsperado);
                
                if (!pagamentoConfirmado) {
                    const valorNormalizado = normalizarValor(valorEsperado);
                    const tipoProdutoTexto = isSaldo ? 'Saldo' : 'Megas';
                    const produtoTexto = isSaldo ? `${produtoConvertido}MT` : produto;
                    console.log(`‚ùå INDIVIDUAL: Pagamento n√£o confirmado para texto (${tipoProdutoTexto}) - ${referencia} (${valorNormalizado}MT)`);

                    await message.reply(
                        `‚è≥ *AGUARDANDO CONFIRMA√á√ÉO DO PAGAMENTO*\n\n` +
                        `üí∞ Refer√™ncia: ${referencia}\n` +
                        `üìä ${tipoProdutoTexto}: ${produtoTexto}\n` +
                        `üì± N√∫mero: ${numero}\n` +
                        `üí≥ Valor esperado: ${valorNormalizado}MT\n\n` +
                        `üîç Aguardando confirma√ß√£o do pagamento na planilha...\n` +
                        `‚è±Ô∏è Tente novamente em alguns minutos.`
                    );
                    return;
                }
                
                console.log(`‚úÖ INDIVIDUAL: Pagamento confirmado para texto (${isSaldo ? 'SALDO' : 'MEGAS'})! Processando...`);

                // 3. Se pagamento confirmado, processar normalmente
                if (isSaldo) {
                    // Processar saldo
                    await enviarSaldoParaTasker(referencia, produtoConvertido, numero, message.from, message);
                    await registrarComprador(message.from, numero, nomeContato, produtoConvertido);
                } else {
                    // Processar megas
                    await enviarComSubdivisaoAutomatica(referencia, produtoConvertido, numero, message.from, message);
                    await registrarComprador(message.from, numero, nomeContato, resultadoIA.valorPago || produto);
                }
                
                if (message.from === ENCAMINHAMENTO_CONFIG.grupoOrigem) {
                    const timestampMensagem = new Date().toLocaleString('pt-BR');
                    adicionarNaFila(dadosCompletos, autorMensagem, configGrupo.nome, timestampMensagem);
                }
                
                const tipoProdutoTexto = isSaldo ? 'Saldo' : 'Megas';
                const produtoTexto = isSaldo ? `${produtoConvertido}MT` : produto;

                await message.reply(
                    `‚úÖ *Pedido processado!*\n\n` +
                    `üí∞ Refer√™ncia: ${referencia}\n` +
                    `üìä ${tipoProdutoTexto}: ${produtoTexto}\n` +
                    `üì± N√∫mero: ${numero}\n` +
                    `üí≥ Pagamento: ${normalizarValor(valorEsperado)}MT confirmado\n\n` +
                    `‚è≥ *Aguarde uns instantes enquanto o sistema executa a transfer√™ncia*`
                );
                return;
            }
        }

        // === TRATAMENTO DE ERROS/CASOS ESPECIAIS ===
        if (resultadoIA.tipo === 'imagem_duplicada') {
            await message.reply(resultadoIA.mensagem);
            return;
            
        } else if (resultadoIA.tipo === 'valor_nao_encontrado_na_tabela') {
            await message.reply(resultadoIA.mensagem);
            return;
            
        } else if (resultadoIA.tipo === 'dados_inconsistentes') {
            await message.reply(resultadoIA.mensagem);
            return;
            
        } else if (resultadoIA.tipo === 'numero_sem_comprovante') {
            await message.reply(
                `üì± *N√∫mero detectado*\n\n` +
                `‚ùå N√£o encontrei seu comprovante.\n\n` +
                `üìù Envie primeiro o comprovante de pagamento.`
            );
            return;
            
        } else if (resultadoIA.tipo === 'multiplos_numeros_nao_permitido') {
            console.log('üîÑ IA detectou m√∫ltiplos n√∫meros, redirecionando para bot de divis√£o...');
            
            const resultadoDivisaoTexto = await botDivisao.processarMensagem(
                message, 
                remetente, 
                message.from
            );
            
            if (resultadoDivisaoTexto && resultadoDivisaoTexto.resposta) {
                await message.reply(resultadoDivisaoTexto.resposta);
            } else {
                // Fallback para a mensagem original se o bot de divis√£o n√£o processar
                await message.reply(
                    `üì± *${resultadoIA.numeros.length} n√∫meros detectados*\n\n` +
                    `‚ùå Sistema atacado aceita apenas UM n√∫mero por vez.\n\n` +
                    `üìù Envie apenas um n√∫mero para receber o valor integral.`
                );
            }
            
            return;
        }

    } catch (error) {
        console.error('‚ùå Erro ao processar mensagem:', error);
    }
});

// Vari√°vel para controlar reconex√£o
let reconnecting = false;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;

client.on('disconnected', async (reason) => {
    console.log('‚ùå Bot atacado desconectado:', reason);
    
    if (!reconnecting && reconnectAttempts < maxReconnectAttempts) {
        reconnecting = true;
        reconnectAttempts++;
        
        console.log(`üîÑ Tentando reconectar... (Tentativa ${reconnectAttempts}/${maxReconnectAttempts})`);
        
        setTimeout(async () => {
            try {
                await client.initialize();
                console.log('‚úÖ Reconectado com sucesso!');
                reconnecting = false;
                reconnectAttempts = 0;
            } catch (error) {
                console.error('‚ùå Falha na reconex√£o:', error);
                reconnecting = false;
                
                if (reconnectAttempts >= maxReconnectAttempts) {
                    console.log('‚ùå M√°ximo de tentativas de reconex√£o atingido. Reinicialize manualmente.');
                }
            }
        }, 5000 * reconnectAttempts); // Delay progressivo
    }
});

// Evento para detectar quando a sess√£o √© destru√≠da
client.on('auth_failure', (message) => {
    console.error('‚ùå Falha na autentica√ß√£o:', message);
    reconnectAttempts = 0; // Reset para permitir novas tentativas
});

// Capturar erros do Puppeteer
client.on('change_state', (state) => {
    console.log('üîÑ Estado do cliente mudou para:', state);
});

// Adicionar tratamento para erros de protocolo
process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Promise rejeitada:', reason);
    
    // Se for erro de contexto destru√≠do, tentar reconectar
    if (reason && reason.message && reason.message.includes('Execution context was destroyed')) {
        console.log('üîÑ Erro de contexto detectado, for√ßando reconex√£o...');
        if (!reconnecting) {
            client.emit('disconnected', 'Execution context destroyed');
        }
    }
});

// === INICIALIZA√á√ÉO ===
client.initialize();

// Salvar hist√≥rico a cada 5 minutos
setInterval(salvarHistorico, 5 * 60 * 1000);

// Limpar dados antigos do Tasker a cada hora
setInterval(() => {
    if (dadosParaTasker.length > 200) {
        dadosParaTasker = dadosParaTasker.slice(-100);
        console.log('üóëÔ∏è Dados antigos do Tasker atacado removidos');
    }
}, 60 * 60 * 1000);

// Limpar cache de grupos logados a cada 2 horas
setInterval(() => {
    gruposLogados.clear();
    console.log('üóëÔ∏è Cache de grupos detectados limpo');
}, 2 * 60 * 60 * 1000);

process.on('SIGINT', async () => {
    console.log('\nüíæ Salvando antes de sair...');
    await salvarHistorico();
    
    // Salvar dados finais do Tasker
    if (dadosParaTasker.length > 0) {
        const dadosFinais = dadosParaTasker.map(d => d.dados).join('\n');
        await fs.writeFile('tasker_backup_final_atacado.txt', dadosFinais);
        console.log('üíæ Backup final do Tasker atacado salvo!');
    }
    
    console.log('üß† IA: ATIVA');
    console.log('üì¶ Sistema atacado: C√ÅLCULO AUTOM√ÅTICO DE MEGAS');
    console.log('üìä Google Sheets ATACADO: CONFIGURADO');
    console.log(`üîó URL: ${GOOGLE_SHEETS_CONFIG_ATACADO.scriptUrl}`);
    console.log(ia.getStatus());
    process.exit(0);

});


